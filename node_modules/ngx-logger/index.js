import { CommonModule, isPlatformBrowser } from '@angular/common';
import { HttpClient, HttpClientModule, HttpHeaders } from '@angular/common/http';
import { Inject, Injectable, NgModule, Optional, PLATFORM_ID } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var LoggerConfig = /** @class */ (function () {
    function LoggerConfig() {
    }
    return LoggerConfig;
}());
/** @enum {number} */
var NgxLoggerLevel = {
    TRACE: 0,
    DEBUG: 1,
    INFO: 2,
    LOG: 3,
    WARN: 4,
    ERROR: 5,
    OFF: 6,
};
NgxLoggerLevel[NgxLoggerLevel.TRACE] = "TRACE";
NgxLoggerLevel[NgxLoggerLevel.DEBUG] = "DEBUG";
NgxLoggerLevel[NgxLoggerLevel.INFO] = "INFO";
NgxLoggerLevel[NgxLoggerLevel.LOG] = "LOG";
NgxLoggerLevel[NgxLoggerLevel.WARN] = "WARN";
NgxLoggerLevel[NgxLoggerLevel.ERROR] = "ERROR";
NgxLoggerLevel[NgxLoggerLevel.OFF] = "OFF";
var Levels = [
    'TRACE',
    'DEBUG',
    'INFO',
    'LOG',
    'WARN',
    'ERROR',
    'OFF'
];
var NGXLogger = /** @class */ (function () {
    function NGXLogger(http$$1, platformId, options) {
        this.http = http$$1;
        this.platformId = platformId;
        this.options = options;
        this.options = this.options ? this.options : {
            level: NgxLoggerLevel.OFF,
            serverLogLevel: NgxLoggerLevel.OFF
        };
        this._serverLogLevel = this.options.serverLogLevel;
        this._clientLogLevel = this.options.level;
        this._isIE = isPlatformBrowser(platformId) &&
            !!(navigator.userAgent.indexOf('MSIE') !== -1 || navigator.userAgent.match(/Trident\//) || navigator.userAgent.match(/Edge\//));
    }
    /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    NGXLogger.prototype.trace = /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    function (message) {
        var additional = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            additional[_i - 1] = arguments[_i];
        }
        this._log(NgxLoggerLevel.TRACE, true, message, additional);
    };
    /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    NGXLogger.prototype.debug = /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    function (message) {
        var additional = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            additional[_i - 1] = arguments[_i];
        }
        this._log(NgxLoggerLevel.DEBUG, true, message, additional);
    };
    /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    NGXLogger.prototype.info = /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    function (message) {
        var additional = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            additional[_i - 1] = arguments[_i];
        }
        this._log(NgxLoggerLevel.INFO, true, message, additional);
    };
    /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    NGXLogger.prototype.log = /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    function (message) {
        var additional = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            additional[_i - 1] = arguments[_i];
        }
        this._log(NgxLoggerLevel.LOG, true, message, additional);
    };
    /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    NGXLogger.prototype.warn = /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    function (message) {
        var additional = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            additional[_i - 1] = arguments[_i];
        }
        this._log(NgxLoggerLevel.WARN, true, message, additional);
    };
    /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    NGXLogger.prototype.error = /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    function (message) {
        var additional = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            additional[_i - 1] = arguments[_i];
        }
        this._log(NgxLoggerLevel.ERROR, true, message, additional);
    };
    /**
     * @return {?}
     */
    NGXLogger.prototype._timestamp = /**
     * @return {?}
     */
    function () {
        return new Date().toISOString();
    };
    /**
     * @param {?} level
     * @param {?} message
     * @param {?=} additional
     * @return {?}
     */
    NGXLogger.prototype._logOnServer = /**
     * @param {?} level
     * @param {?} message
     * @param {?=} additional
     * @return {?}
     */
    function (level, message, additional) {
        var _this = this;
        if (additional === void 0) { additional = []; }
        // If the loggingUrl is not set or if the user provides a serverLogLevel and the current level is than that, do not log.
        if (!this.options.serverLoggingUrl || level < this._serverLogLevel) {
            return;
        }
        var /** @type {?} */ headers = new HttpHeaders().set('Content-Type', 'application/json');
        var /** @type {?} */ messageToLog = '';
        try {
            messageToLog = JSON.stringify(message);
        }
        catch (/** @type {?} */ e) {
            messageToLog = 'The provided "message" value could not be parsed with JSON.stringify().';
        }
        var /** @type {?} */ additionalToLog = [];
        if (additional === null || additional === undefined) {
            additionalToLog = [];
        }
        else {
            additionalToLog = additional.map(function (val, idx) {
                try {
                    return val === null || val === undefined || typeof val === 'string' ? val
                        : JSON.stringify(val, null, 2);
                }
                catch (/** @type {?} */ e) {
                    return "The additional[" + idx + "] value could not be parsed using JSON.stringify().";
                }
            });
        }
        this.http.post(this.options.serverLoggingUrl, {
            level: Levels[level],
            message: messageToLog,
            additional: additionalToLog,
            timestamp: this._timestamp()
        }, {
            headers: headers
        })
            .subscribe(function (res) { return _this._log(NgxLoggerLevel.TRACE, false, 'Server logging successful', [res]); }, function (error) { return _this._log(NgxLoggerLevel.ERROR, false, 'FAILED TO LOG ON SERVER', [error]); });
    };
    /**
     * @param {?} level
     * @param {?} message
     * @param {?=} additional
     * @return {?}
     */
    NGXLogger.prototype._logIE = /**
     * @param {?} level
     * @param {?} message
     * @param {?=} additional
     * @return {?}
     */
    function (level, message, additional) {
        if (additional === void 0) { additional = []; }
        switch (level) {
            case NgxLoggerLevel.WARN:
                console.warn.apply(console, [this._timestamp() + " [" + Levels[level] + "] ", message].concat(additional));
                break;
            case NgxLoggerLevel.ERROR:
                console.error.apply(console, [this._timestamp() + " [" + Levels[level] + "] ", message].concat(additional));
                break;
            case NgxLoggerLevel.INFO:
                console.info.apply(console, [this._timestamp() + " [" + Levels[level] + "] ", message].concat(additional));
                break;
            default:
                console.log.apply(console, [this._timestamp() + " [" + Levels[level] + "] ", message].concat(additional));
        }
    };
    /**
     * @param {?} level
     * @param {?} logOnServer
     * @param {?} message
     * @param {?=} additional
     * @return {?}
     */
    NGXLogger.prototype._log = /**
     * @param {?} level
     * @param {?} logOnServer
     * @param {?} message
     * @param {?=} additional
     * @return {?}
     */
    function (level, logOnServer, message, additional) {
        if (additional === void 0) { additional = []; }
        if (!message) {
            return;
        }
        // Allow logging on server even if client log level is off
        if (logOnServer) {
            this._logOnServer(level, message, additional);
        }
        // if no message or the log level is less than the environ
        if (level < this._clientLogLevel) {
            return;
        }
        try {
            message = typeof message === 'string' ? message
                : JSON.stringify(message, null, 2);
        }
        catch (/** @type {?} */ e) {
            additional = [message].concat(additional);
            message = 'The provided "message" value could not be parsed with JSON.stringify().';
        }
        // Coloring doesn't work in IE
        if (this._isIE) {
            return this._logIE(level, message, additional);
        }
        var /** @type {?} */ color = this._getColor(level);
        console.log.apply(console, ["%c" + this._timestamp() + " [" + Levels[level] + "]", "color:" + color, message].concat(additional));
    };
    /**
     * @param {?} level
     * @return {?}
     */
    NGXLogger.prototype._getColor = /**
     * @param {?} level
     * @return {?}
     */
    function (level) {
        switch (level) {
            case NgxLoggerLevel.TRACE:
                return 'blue';
            case NgxLoggerLevel.DEBUG:
                return 'teal';
            case NgxLoggerLevel.INFO:
            case NgxLoggerLevel.LOG:
                return 'gray';
            case NgxLoggerLevel.WARN:
            case NgxLoggerLevel.ERROR:
                return 'red';
            case NgxLoggerLevel.OFF:
            default:
                return;
        }
    };
    NGXLogger.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    NGXLogger.ctorParameters = function () { return [
        { type: HttpClient, },
        { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] },] },
        { type: LoggerConfig, decorators: [{ type: Optional },] },
    ]; };
    return NGXLogger;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var NGXLoggerMock = /** @class */ (function () {
    function NGXLoggerMock() {
    }
    /**
     * @param {?} message
     * @return {?}
     */
    NGXLoggerMock.prototype.trace = /**
     * @param {?} message
     * @return {?}
     */
    function (message) {
    };
    /**
     * @param {?} message
     * @return {?}
     */
    NGXLoggerMock.prototype.debug = /**
     * @param {?} message
     * @return {?}
     */
    function (message) {
    };
    /**
     * @param {?} message
     * @return {?}
     */
    NGXLoggerMock.prototype.info = /**
     * @param {?} message
     * @return {?}
     */
    function (message) {
    };
    /**
     * @param {?} message
     * @return {?}
     */
    NGXLoggerMock.prototype.log = /**
     * @param {?} message
     * @return {?}
     */
    function (message) {
    };
    /**
     * @param {?} message
     * @return {?}
     */
    NGXLoggerMock.prototype.warn = /**
     * @param {?} message
     * @return {?}
     */
    function (message) {
    };
    /**
     * @param {?} message
     * @return {?}
     */
    NGXLoggerMock.prototype.error = /**
     * @param {?} message
     * @return {?}
     */
    function (message) {
    };
    NGXLoggerMock.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    NGXLoggerMock.ctorParameters = function () { return []; };
    return NGXLoggerMock;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var LoggerModule = /** @class */ (function () {
    function LoggerModule() {
    }
    /**
     * @param {?} config
     * @return {?}
     */
    LoggerModule.forRoot = /**
     * @param {?} config
     * @return {?}
     */
    function (config) {
        return {
            ngModule: LoggerModule,
            providers: [
                { provide: LoggerConfig, useValue: config || {} },
                NGXLogger,
                NGXLoggerMock
            ]
        };
    };
    /**
     * @return {?}
     */
    LoggerModule.forChild = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: LoggerModule,
            providers: [
                NGXLogger,
                NGXLoggerMock
            ]
        };
    };
    LoggerModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        HttpClientModule
                    ]
                },] },
    ];
    /** @nocollapse */
    LoggerModule.ctorParameters = function () { return []; };
    return LoggerModule;
}());

export { LoggerModule, NGXLoggerMock, LoggerConfig, NgxLoggerLevel, NGXLogger };
